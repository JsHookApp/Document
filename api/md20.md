# memory

If your model cannot input QX driver, you can use this interface to directly read and write the target application memory in kernel mode

## memory.getModuleBase(libname)

Get the memory address of a certain so shared library, which can be used for memory offset calculation

`Parameter`:

`libname`: string

`Return value`: string

## memory.readDword(address)

Get the integer value of the memory address

`Parameter`:

`address`: string

`Return value`: long

## memory.readFloat(address)

Get the floating point value of the memory address

`Parameter`:

`address`: string

`Return value`: float

## memory.writeDword(address,value)

Write the integer value of the memory address

`Parameter`:

`address`: string

`value`: long

`Return value`: int

## memory.writeFloat(address,value)

Write floating point value to memory address

`Parameters`:

`address`: string

`value`: float

`Return value`: int

## Sample script

First download the target application for practice [https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida.apk](https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida.apk)

And the corresponding `dump.cs` file [https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida_dump.cs](https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida_dump.cs)

The `Learn.Frida_dump.cs` file mainly analyzes `public class FieldTest: MonoBehaviour`Method here

The following is a script example. In the script, frida is used to find the memory base address in non-kernel mode. Of course, you can use other methods to find the memory base address. Click the `ShowResult` button to display an input box for entering the current `staticA` value to search for the memory address

```javascript
//Memory scan
const memoryScan = (m, pattern, call) => {
    Memory.scan(m.base, m.size, pattern, {
        onMatch(address, size) {
            call(address);
            return 'stop';
        },
        onComplete() {
        }
    });
};

function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

//Start using the kernel
if (runtime.isKernel) {

    console.log('kernel start');

    const time = setInterval(() => {
        const il2cpp = memory.getModuleBase('libil2cpp.so');
        if (il2cpp) {
            clearInterval(time);
            console.log('il2cpp', il2cpp);

            //Read/modify data
            setInterval(() => {
                const newval = getRandomInt(100, 999);
                console.log('newval', newval);
                memory.writeDword('0x7e3fe30c30', newval);

                const memory_staticA = memory.readDword('0x7e3fe30c30');
                console.log('staticA', memory_staticA);
            }, 3000);
        }
    }, 100);
} else {

    //Find the memory base address of the variable through frida in non-kernel mode, you can also get it through other methods

    const time = setInterval(() => {
        const addr = Module.findBaseAddress('libil2cpp.so');
        if (addr) {
            clearInterval(time);
            console.log('libil2cpp ok');
            //il2cpp module address is dynamic
            const il2cpp = ptr(addr);
            console.log('il2cpp', il2cpp);
            //This 0x667F14 is an offset, fixed, pointing to the ShowResult method
            Interceptor.attach(il2cpp.add(0x667F14), {
                onEnter: function (args) {
                    //Current instance
                    const instance = args[0];

                    //Enter the current value of staticA to search memory
                    dialog.input('search_val', {
                        ok: function (res) {

                            //Get the search range
                            const range = Process.findRangeByAddress(instance);

                            //Search condition
                            const pattern = ptr(parseInt(res)).toMatchPattern().replace(' 00 00 00 00', '');

                            memoryScan(range, pattern, (address) => {
                                //Variable memory address
                                console.log('staticA_address', address);

                                Java.perform(function () {
                                    //Variable memory value, read using memory interface
                                    const staticA = memory.readDword(String(address));
                                    console.log('staticA', staticA);

                                    //Modify, modify using memory interface
                                    memory.writeDword(String(address), 1000);
                                });
                            });
                        },
                        cancel: function () {
                        }
                    }, '');
                },
                onLeave: function (retval) {
                }
            });
        }
    }, 100);

}
```
